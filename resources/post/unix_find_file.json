{
    "id" : "2",
    "level" : "Expert",
    "tags" :["ambiguity", "ood"],
    "date" : "24-Dec-2020",
    "title" : "Designing File Search",
    "description" : "A walkthrough of designing a File Search and how we can think about extensibility",   
    "body" : "<h3><strong>The Question</strong></h3><p>Implement the find command.&nbsp;Initial usecases are:</p><ul><li>Find file with name starting with \"A\"</li><li>Find PDF files.</li></ul><p>Create a library that lets me do this easily. The code should be easily extensible to other usecases.</p><div>&nbsp;</div><h3><strong>The Test</strong></h3><p>The test is to identify that these are just 2 uses cases and that the library should be flexible enough to support all that we might need from a search service. Ofc we wont build everthing today but we need to leave room for those developments to come along easily. The key here is understanding that we are building a \"Find\" Service/library.</p><h3><strong>The Approaches</strong></h3><p>As a Snr SDE you are expected to understand that the 2 usecases are merely a query string to our search service. Although hardcoded, it is important to probe if there is a scope of extention of query language and will user be able to&nbsp;SOMEDAY&nbsp;provide search queries.</p><p>From the above we can deduce that the SDE must ask:</p><ol><li>Will there be more&nbsp;params which can be used to query creation other than Filesize or type.</li><li>Will there ever be combined to create a complex query.</li></ol><p>If you we able to reach the above two questions, congratulations you have solved the toughest part of the question.</p><p>&nbsp;</p><h3><strong>The Solution</strong></h3><p>We need to just ensure that we create something of a basic query implementation and resolution framework. To do that we need the following</p><p><strong>Important consederation</strong></p><ol><li>The query should be based of an interface which can be formed using Composite Pattern</li><li>rule matcher interface for abstraction (interface with match method).</li><li>Implement simple&nbsp;DFS/BFS&nbsp;file search for searching.&nbsp;</li><li>Implement logical operators for matcher (AND, OR, NOT).&nbsp;</li></ol><p>Additionally as an edge case you&nbsp;should think of \"handling symbolic links\".</p><p>the flow will be like</p><p>(RuleMatcher)-&gt;Name&nbsp;Matcher&nbsp;</p><p>(RuleMatcher)-&gt;AND Matcher // this should accept multiple rules and ensure all are true.</p><p>And similarly other classes can be made.</p><p>&nbsp;</p><p><strong>Psudo Code eg</strong></p><p>Some cases are missing but this should give you a good idea&nbsp;</p><div class=\"code\"><p>interface Rule {<br /> &nbsp;&nbsp;&nbsp;public boolean match(File f);<br />}<br /><br />class&nbsp;NameRule implements Rule {<br />&nbsp; &nbsp; boolean match(File f) {<br />&nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;name (NameMatch(-&gt;preferably enum startWith EndWith etc)) Value<br /> &nbsp;&nbsp;&nbsp;}<br />}<br /><br />public class InSizeOp implements Rule {<br />&nbsp;boolean match(File f) {<br />&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return if&nbsp; file&nbsp;size &nbsp;between LOWER &amp;&amp; UPPER<br />&nbsp; &nbsp; }<br />}<br /><br />class&nbsp;ANDRule implements Rule {<br />&nbsp; &nbsp; Rule[] andRules;<br /><br /> &nbsp;&nbsp;&nbsp;boolean match(File f) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (Rule rule : andRules)&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;any does return flase<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br /> &nbsp;&nbsp;&nbsp;}<br />}<br /><br />class FindFile {<br />&nbsp; &nbsp;&nbsp;public Files[] traverse(directoryPath, rule){</p><p>&nbsp; &nbsp; //traverse using any DFS or BFS and keep adding as you find match</p><p>&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp;&nbsp;start:-&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; rule = new ANDOperator(new SizeOperator(150,INFINITE), new ExtentionOperation(\"PDF), OROperator(new MetadataMatchOperation())....;<br />&nbsp; &nbsp; &nbsp; &nbsp; traverse(\"/local/home\", rule);<br /> &nbsp;&nbsp;&nbsp;}<br />}</p></div>",
    "endText": ""
}